/**
 * .. _asdf/core/ndarray.h:
 *
 * Minimalistic prototype implementation of the
 * :ref:`stsci.edu/asdf/core/ndarray-1.1.0` schema
 *
 * Support is not yet fully complete.  What is implemented:
 *
 * It can provide direct access to the raw data of an ndarray (via a
 * ``void *``); users must use
 * the metadata provided in the `asdf_ndarray_t` struct to interpret the data.
 * However, data can also be copied as tiles using the
 * `asdf_ndarray_read_tile_ndim` and `asdf_ndarray_read_tile_2d` functions.
 *
 * * ASDF internal block sources
 * * All int and most float data types (other data types can be read but are
 *   not fully implemented)
 * * :c:member:`shape <asdf_ndarray_t.shape>`,
 *   :c:member:`byeorder <asdf_ndarray_t.byteorder>`, and
 *   :c:member:`offset <asdf_ndarray_t.offset>`
 * * :c:member:`strides <asdf_ndarray_t.strides>` are partially supported
 *
 * What is not yet supported:
 *
 * * Shape containing '*'
 * * Reading ``complex64`` or ``complex128``, or ``float16`` datatypes
 * * Reading string datatypes (``ascii`` or ``ucs4``)
 * * Reading structured datatypes (the datatypes are parsed but there is are
 *   no APIs yet for interpreted structured array data
 * * Reading arbitrarily strided data
 * * Reading inline array ``data``
 * * Masks are not parsed or used at all, whether simple mask values or mask
 *   arrays (though if present a warning is logged indicating lack of support)
 *
 * The current limitations are purely aritificial--it is so that we can rapidly
 * develop the minimal viable product needed to make ASDF ndarray data
 * available in common use cases.
 *
 * Complete ndarray support will follow gradually.
 */

//

#ifndef ASDF_CORE_NDARRAY_H
#define ASDF_CORE_NDARRAY_H

#include <stddef.h>
#include <stdint.h>

#include <asdf/core/datatype.h>
#include <asdf/extension.h>
#include <asdf/util.h>

ASDF_BEGIN_DECLS

#define ASDF_CORE_NDARRAY_TAG ASDF_CORE_TAG_PREFIX "ndarray-1.1.0"


/**
 * Error codes returned by some functions that read ndarray data
 */
typedef enum {
    /** Indicates that the ndarray was read successfully */
    ASDF_NDARRAY_OK = 0,
    /**
     * Return value indicating that an attempt was made to read beyond the
     * bounds of the ndarray
     */
    ASDF_NDARRAY_ERR_OUT_OF_BOUNDS,
    ASDF_NDARRAY_ERR_OOM,
    ASDF_NDARRAY_ERR_INVAL,
    ASDF_NDARRAY_ERR_OVERFLOW,
    ASDF_NDARRAY_ERR_CONVERSION,
} asdf_ndarray_err_t;


#ifndef ASDF_CORE_NDARRAY_INTERNAL
/**
 * Public definition of the `asdf_ndarray_t` type
 *
 * This is the main object through which ndarrays are used.  They can be
 * retrieved via `asdf_get_ndarray` and `asdf_value_as_ndarray`.  The library
 * allocates memory for this data structure which must be freed by the user with
 * `asdf_ndarray_destroy` when no-longer needed..
 *
 * For convenience some basic fields are made public for now, though this may
 * not be ABI-stable in future releases.
 */
typedef struct {
    /** The index of the binary block containing the ndarray data */
    size_t source;
    /** The number of dimensions of the array */
    uint32_t ndim;
    /** The shape of the array, itself an array of size ``.ndim`` */
    uint64_t *shape;
    /** The datatype of the array as represented by `asdf_datatype_t` */
    asdf_datatype_t datatype;
    /** The byteorder of the array data where appliable */
    asdf_byteorder_t byteorder;
    /** Optional offset into the binary block where the array data begins */
    uint64_t offset;
    /**
     * Optional strides to use when iterating/index array data (an array of
     * size ``.ndim`` giving the stride for each dimension)
     */
    int64_t *strides;
} asdf_ndarray_t;
#else
typedef struct asdf_ndarray asdf_ndarray_t;
#endif


// NOTE: For now I don't see any good way to generate docstrings for functions
// generated by ASDF_DECLARE_EXTENSION, so we just insert them manually for
// now.  Should be possible with a custom extension to Sphinx (or Hawkmoth)
// but not worth the effort short-term.
//

// clang-format off

/**
 * .. c:function:: asdf_value_err_t asdf_get_ndarray(asdf_file_t *file, const char *path, asdf_ndarray_t **out)
 *
 *   Get an `asdf_ndarray_t *` out of the ASDF tree
 *
 *   :param file: The `asdf_file_t *` for the file
 *   :param path: The :ref:`yaml-pointer` to the ndarray
 *   :param out: An `asdf_ndarray_t **` into which to return the `asdf_ndarray_t *`
 *
 *   :return: `ASDF_VALUE_OK` if the value exists and is an ndarray, otherwise
 *     `ASDF_VALUE_ERR_NOT_FOUND` or `ASDF_VALUE_ERR_TYPE_MISMATCH`.
 */


/**
 * .. c:function:: asdf_value_err_t asdf_value_as_ndarray(asdf_value_t *value, asdf_ndarray_t **out)
 *
 *   Cast a generic `asdf_value_t *` as an ndarray value, if possible
 *
 *   :param value: The `asdf_value_t *` handle
 *   :param out: An `asdf_ndarray_t **` into which to return the `asdf_ndarray_t *`
 *
 *   :return: `ASDF_VALUE_OK` if the value is an ndarray, otherwise
 *     `ASDF_VALUE_ERR_TYPE_MISMATCH`.
 */


/**
 * .. c:function:: void asdf_ndarray_destroy(asdf_ndarray_t *ndarray)
 *
 *   Release datastructures and memory allocated for an `asdf_ndarray_t`
 *
 *   :param value: The `asdf_ndarray_t *`
 */

// clang-format on

ASDF_DECLARE_EXTENSION(ndarray, asdf_ndarray_t);


/** ndarray methods */
ASDF_EXPORT const void *asdf_ndarray_data_raw(asdf_ndarray_t *ndarray, size_t *size);

/**
 * Return the total number of elements (not bytes) in the ndarray
 *
 * :param ndarray: An `asdf_ndarray_t *`
 * :return: Total number of elements in the array (just the product of its
 *   shape)
 */
ASDF_EXPORT size_t asdf_ndarray_size(asdf_ndarray_t *ndarray);


/**
 * Get the pointer to the open `asdf_block_t` associated with the ndarray
 *
 * This is mostly for debugging/low-level inspection and is not needed for
 * typical use cases.
 *
 * :param ndarray: An `asdf_ndarray_t *`
 * :return: A constant pointer to the `asdf_block_t` structure representing
 *   the binary block underlying the array, if any.  This will be `NULL`, for
 *   example, if the ndarray used inline data.
 */
ASDF_EXPORT const asdf_block_t *asdf_ndarray_block(asdf_ndarray_t *ndarray);


/**
 * Read the full ndarray, copying into the provided buffer (or allocating a
 * destination buffer if ``dst = NULL``)
 *
 * This is like `asdf_ndarray_read_tile_ndim` but with a default "tile" size
 * of the full array.  Like `asdf_ndarray_read_tile_ndim` it will also convert
 * the data to the host native byte order if necessary, and can convert it to a
 * different numeric type than the source array.
 *
 * :param ndarray: The `asdf_ndarray_t *` handle to the ndarray
 * :param dst_t: An `asdf_scalar_datatype_t` to convert to, or
 *   `ASDF_DATATYPE_SOURCE` to keep the original source datatype
 * :param dst: Pointer to a destination `void *` already allocated to receive
 *   the exact number of bytes in the source ndarray, or `NULL` to indicate
 *   that a buffer should be allocated.  In the latter case the caller is
 *   responsible for freeing the allocated buffer.
 */
ASDF_EXPORT asdf_ndarray_err_t
asdf_ndarray_read_all(asdf_ndarray_t *ndarray, asdf_scalar_datatype_t dst_t, void **dst);

/**
 * Read tiles of up to N-dimensions out of N-D arrays
 *
 * Tiles can be slices of any number of dimenions <= N and of any shape so long
 * as they don't go past the bounds of the array (otherwise
 * `ASDF_NDARRAY_ERR_OUT_OF_BOUNDS` is returned).
 *
 * :param ndarray: The `asdf_ndarray_t *` handle to the ndarray
 * :param origin: The indices of the first pixel of the tile--an array of size
 *   :c:member:`ndim <asdf_ndarray_t.ndim>`
 * :param shape: The shape of the tile to read--an array of size
 *   :c:member:`ndim <asdf_ndarray_t.ndim>`
 * :param: dst_t: The output datatype, if conversion from the source array's
 *   datatype to the output datatype is possible
 *
 *   Currently, if no conversion is possible it will just copy the tile data
 *   without conversion--this may change in the future to become an error.
 *   You can pass the special value `ASDF_DATATYPE_SOURCE` to indicate that
 *   the output datatype is the source datatype.
 * :param dst: Pointer to a destination `void *` already allocated to receive
 *   the exact number of bytes in the output tile based on shape and datatype,
 *   or `NULL` to indicate that a buffer should be allocated.  In the latter
 *   case the caller is responsible for freeing the allocated buffer.
 */
ASDF_EXPORT asdf_ndarray_err_t asdf_ndarray_read_tile_ndim(
    asdf_ndarray_t *ndarray,
    const uint64_t *origin,
    const uint64_t *shape,
    asdf_scalar_datatype_t dst_t,
    void **dst);

/**
 * Like `asdf_ndarray_read_tile_ndim` but with conveniences for the common 2-D
 * case
 *
 * :param ndarray: The `asdf_ndarray_t *` handle to the ndarray
 * :param x: The x coordinate of the tile origin
 * :param y: The y coordinate of the tile origin
 * :param width: The width of the tile in the x direction
 * :param height: The height of the tile in the y direction
 * :param plane_origin: If the source array is greater than 2-dimensional, the
 *   ``ndim - 2`` array of plane coordinates--may be `NULL` if either the source
 *   array is 2-D or otherwise the outer-most plane is used
 * :param: dst_t: The output datatype, if conversion from the source array's
 *   datatype to the output datatype is possible
 *
 *   Currently, if no conversion is possible it will just copy the tile data
 *   without conversion--this may change in the future to become an error.
 *   You can pass the special value `ASDF_DATATYPE_SOURCE` to indicate that
 *   the output datatype is the source datatype.
 * :param dst: Pointer to a destination `void *` already allocated to receive
 *   the exact number of bytes in the output tile based on shape and datatype,
 *   or `NULL` to indicate that a buffer should be allocated.  In the latter
 *   case the caller is responsible for freeing the allocated buffer.
 */
ASDF_EXPORT asdf_ndarray_err_t asdf_ndarray_read_tile_2d(
    asdf_ndarray_t *ndarray,
    uint64_t x,
    uint64_t y,
    uint64_t width,
    uint64_t height,
    const uint64_t *plane_origin,
    asdf_scalar_datatype_t dst_t,
    void **dst);


ASDF_END_DECLS

#endif /* ASDF_CORE_NDARRAY_H */
